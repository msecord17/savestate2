---
description: Platform sync step order, DB invariants, and idempotency (PSN/Xbox/Steam).
globs: web/app/api/sync/**/*.ts, web/app/api/psn/**/*.ts, web/app/api/steam/sync/*.ts, web/app/api/auth/**/import/*.ts, web/lib/images/*.ts, web/app/api/catalog/backfill-covers/*.ts
alwaysApply: false
---

# Platform sync: step order and idempotency

**Guiding principle:** All platform sync routes must be **idempotent**. Running sync twice must **not** create new games or releases. It must only update signals and fill missing metadata.

## Notes (to avoid common bugs)

- **release_external_ids is the authority:** Always resolve `release_id` from the platform external id (e.g. Steam appid) **first** via `release_external_ids(source, external_id)`. Never create a release before checking the mapping; re-running sync must not create duplicates.
- **Steam:** Use **steam-thin** (`/api/sync/steam-thin`) as the default sync. Keep full sync (`/api/sync/steam`) and lighter sync (`/api/steam/sync`) for **debugging only**; do not wire them as the primary user-facing sync.

## DB invariants (lock the spine)

Enable these indexes **only after** bulk repair (merge duplicate releases, dedupe duplicate games). See `sql/README.md` for run order.

- **games:** unique `games(igdb_game_id)` where not null  
- **releases:** unique `releases(platform_key, game_id)`  
- **release_external_ids:** unique `release_external_ids(source, external_id)`. Table columns are **release_id, source, external_id** only; align all selects/inserts/updates with this schema.

Sync is idempotent by construction when these hold.

## Step order in every sync pipeline

Apply this order for **every** platform (PSN, Xbox, Steam):

1. **Resolve platform external id**  
   PSN title id / Steam appid / Xbox title id.

2. **Find or create `release_external_ids`**  
   Look up `release_external_ids(source, external_id)` → get `release_id` if exists.  
   If a row exists, use that `release_id` and skip to step 4.

3. **If no release exists yet**
   - Resolve IGDB best match → get/create `games` row (by `igdb_game_id` when possible, else `canonical_title`).
   - Get/create `releases` row by `(platform_key, game_id)` (one release per platform per game).
   - Write `release_external_ids(release_id, source, external_id)` so the next run hits step 2.

4. **Update signals tables**  
   Progress / playtime / trophies / achievements caches (e.g. `psn_title_progress`, `xbox_title_progress`, `steam_title_progress`).

This order makes “run sync twice” safe: external id → mapping → release → signals.

## Rules

- **Never create a release** before checking `release_external_ids` for that platform’s external id. Always resolve `release_id` from appid (or equivalent) first.
- **Game identity:** Prefer IGDB (lookup/upsert by `igdb_game_id`); fall back to title-based only when IGDB has no match.
- **Release identity:** One release per `(platform_key, game_id)`; reuse existing row when present.
- **Signals:** Upsert by (user_id, platform_external_id); never create a second row for the same user+title.

## Cover URL rule (implement everywhere — tell Cursor explicitly)

When **setting** or **writing** `cover_url` (on `games` or `releases`):

1. **Prefer `games.cover_url` (IGDB).** Use it as the canonical source when present.
2. **Only use `releases.cover_url` if `game.cover_url` is null.** Do not set release cover when the game already has a valid IGDB cover.
3. **Never overwrite a valid IGDB cover** with platform art (Steam header, PSN icon, Xbox art) or RA screenshots. Check `shouldOverwriteCover()` in `web/lib/igdb/server.ts` before updating; never replace when `images_source` is IGDB or when the current cover is already valid.

When **reading** for display: use `resolveCoverUrl()` so UI gets game.cover_url first, then release.cover_url, then platform/placeholder.

## Images and backfill

- **Cover:** Default from `games.cover_url`; treat `releases.cover_url` as optional override. Use `resolveCoverUrl()` so UI gets game default first, then release override → platform/placeholder.
- **IGDB backfill:** Keep focused on games (fill `games.cover_url` + metadata); then propagate game cover to releases with null/unknown cover only. Do not backfill release-first. Never overwrite a valid IGDB cover.

## Immediate next action (simple) — tell Cursor explicitly

1. **Proceed with:** Xbox alias resolution + non-game ignore + IGDB-wins cover precedence.  
   Ensure these are implemented everywhere they apply: alias resolution and non-game skip in `upsertGameIgdbFirst` (and any sync that calls it); cover precedence per the Cover URL rule above and `shouldOverwriteCover()` when writing covers.

2. **Then run spine-repair until done:**  
   Call `POST /api/admin/spine-repair?limit=100` (or 50). If the response has `has_more: true`, call again with `cursor=<next_cursor>`. Repeat until `has_more: false`.

3. **Report updated spine-health:**  
   Call `GET /api/admin/spine-health` and report the returned numbers (e.g. `games_total`, `games_with_igdb`, `releases_total`, `releases_pending_igdb`, `releases_pending_cover`, `releases_enrichment_failed`).
